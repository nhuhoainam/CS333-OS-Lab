1.
Every system calls that utilize the `copyout()` function can also be optimized using this way, because kernel keeps the physical address of the physical memory, it can directly read and write data to that block of memory. Meanwhile, user has the access to the shared data region => There is no need for kernel crossings anymore because the data can be read in user mode.
=> fstat(), pipe() and wait() system calls are the ones we can optimize.

2.
- The vmprint() give the following result:

page table 0x0000000087f6b000
 ..0: pte 0x0000000021fd9c01 pa 0x0000000087f67000
 .. ..0: pte 0x0000000021fd9801 pa 0x0000000087f66000
 .. .. ..0: pte 0x0000000021fda01b pa 0x0000000087f68000
 .. .. ..1: pte 0x0000000021fd9417 pa 0x0000000087f65000
 .. .. ..2: pte 0x0000000021fd9007 pa 0x0000000087f64000
 .. .. ..3: pte 0x0000000021fd8c17 pa 0x0000000087f63000
 ..255: pte 0x0000000021fda801 pa 0x0000000087f6a000
 .. ..511: pte 0x0000000021fda401 pa 0x0000000087f69000
 .. .. ..509: pte 0x0000000021fdcc13 pa 0x0000000087f73000
 .. .. ..510: pte 0x0000000021fdd007 pa 0x0000000087f74000
 .. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000

- Page 0 contains data and text
- Page 2 is the stack 
- When running in user mode, process can not read/write the memory mapped in page, because it is the guard page to protect the stack from being accessed by user.
- Page 3 - last page contains heap, trapframe and trampoline.